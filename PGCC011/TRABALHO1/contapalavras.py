# -*- coding: utf-8 -*-
"""contaPalavras.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Lob21JkUKP48yU6sw_D-5UT1nHMK_9Z-
"""

# UEFS - Universidade Estadual de Feira de Santana
# PGCC - Pós-Graduação em Ciências da Computação
# PGCC011 - Computação de Alto Desempenho
# Professor..: Angelo Amâncio Duarte  
# Aluno¹.....: Luciano Alves Machado Junior
# Aluno².....: Marcos Morais de sousa

# 3. Codifique a versão serial do algoritmo sorteado em Python v3.
# 	a. Levante a curva de escalabilidade em função do tamanho do problema;
# 	b. Use os mesmos requisitos de carga do item 1

# Programa C++ para calcular a frequência
# de cada palavra na string dada
# Função para imprimir a freqüência de cada palavra
def mapearPalavras(linha, M):
	
	# string para armazenar as palavras
	palavra = ""
	c = ""
	for c in linha:
		c=c.lower()
		# Verifique se o personagem atual
		# é um espaço em branco, então
		# significa que temos uma palavra
		if (c == ' '):
			if len(palavra)>1:
				# Se a palavra atual
				# não foi encontrado, insira
				# palavra atual com frequência 1
				if (palavra not in M):
					M[palavra] = 1
					palavra = ""
				
				# atualiza a frequência da palavra
				else:
					M[palavra] += 1
					palavra = ""
			else:
				palavra = ""
		
		# Se o caractere "c" atual for uma das opções abaixo, adicionar na "palavra" 
		if (c=='a' or c=='b' or c=='c' or c=='d' or c=='e' or c=='f' or c=='g' or 
			c=='h' or c=='i' or c=='j' or c=='k' or c=='l' or c=='m' or c=='n' or 
			c=='o' or c=='p' or c=='q' or c=='r' or c=='s' or c=='t' or c=='u' or 
			c=='v' or c=='w' or c=='x' or c=='y' or c=='z' or c=='á' or c=='â' or 
			c=='à' or c=='é' or c=='ê' or c=='í' or c=='ó' or c=='ô' or c=='õ' or 
			c=='ã' or c=='ú' or c=='ç'):
			palavra += c
	
	if len(palavra)>1:
		# Armazenando a última palavra da string
		if (palavra not in M):
			M[palavra] = 1
		# Atualize a frequência
		else:
			M[palavra] += 1
		return M
	else:
		return M

# parte principal
M={}
with open("arquivo.txt") as file:
    for line in file:
      M=mapearPalavras(line, M)

from collections import OrderedDict
M = OrderedDict(sorted(M.items(), key=lambda x: x[1], reverse=True))

qntValores=10;
cont=0

arquivo = open('resultadoPy.txt', 'w')
for it in M:
	if cont<qntValores:
		if cont==qntValores-1:
			resultado= str(M[it]) + "=>" + str(it)
		else:
			resultado= str(M[it]) + "=>" + str(it) + "\n"
		arquivo.write(resultado)
		cont+=1
	else:
		break

arquivo.close()